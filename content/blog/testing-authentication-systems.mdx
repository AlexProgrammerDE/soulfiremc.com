---
title: Testing Minecraft Authentication Systems - Security and Login Flow
description: Learn how to test authentication plugins like AuthMe, validate Microsoft/Mojang auth, and ensure secure login flows on your Minecraft server
author: Pistonmaster
date: 2026-02-08
tags: [minecraft, authentication, authme, security, offline-mode, login]
---

import { Callout } from 'fumadocs-ui/components/callout'

## Understanding Minecraft Authentication

Every server needs to decide how it checks who's connecting. Minecraft supports two modes out of the box, and plugins extend offline mode with password-based security.

### Online vs Offline Mode

**Online mode** (`online-mode=true` in `server.properties`) is the default. The server contacts Mojang/Microsoft to verify the player owns the account before allowing them in. It doesn't require any plugins, prevents impersonation via real UUIDs, and is the most secure option. The tradeoff is that Mojang's servers need to be reachable.

**Offline mode** (`online-mode=false`) skips verification entirely. Anyone can connect with any username, which is handy for local development or behind a proxy that handles auth upstream.

<Callout type="danger">
**Never run offline mode on a public server without an authentication plugin.** Without one, any player can join as any username, including admin accounts. This is the single most common way servers get compromised.
</Callout>

### Plugin-Based Authentication

For offline mode servers, authentication plugins add password-based login:

| Plugin | Approach | Best For |
|--------|----------|----------|
| [AuthMe](https://github.com/AuthMe/AuthMeReloaded) | Password registration/login | Public offline servers |
| [FastLogin](https://github.com/games647/FastLogin) | Hybrid online/offline detection | Mixed premium + cracked players |
| nLogin | Simple password auth | Small servers |

## AuthMe Configuration

[AuthMe](https://github.com/AuthMe/AuthMeReloaded) is the most widely used auth plugin. Drop the JAR into your `plugins/` folder and restart; it generates its config on first boot.

### Core Settings

```yaml title="plugins/AuthMe/config.yml"
settings:
  sessions:
    enabled: true
    timeout: 10        # Minutes before requiring re-login
    ipCheck: true      # Bind sessions to IP

registration:
  enabled: true
  force: true
  messageInterval: 5
  maxRegPerIp: 1       # Prevent spam accounts

security:
  minPasswordLength: 5
  maxPasswordLength: 30
  passwordHash: 'BCRYPT2Y'
  bCryptLog2Rounds: 10
  maxLoginTries: 3
  tempBanLength: 5     # Minutes after max failed attempts
  unsafePasswords:
    - '123456'
    - 'password'
    - 'qwerty'

timeout:
  kick: 30             # Seconds before kicking unauthenticated players

restrictions:
  allowCommands:
    - '/login'
    - '/register'
    - '/l'
    - '/reg'
  allowMovement: false
  allowChat: false
```

<Callout type="warning">
**Always use BCRYPT or BCRYPT2Y for password hashing.** SHA256 is vulnerable to rainbow table attacks and should never be used for password storage.
</Callout>

### Database Backend

SQLite works for development, but production servers should use MySQL for better concurrency under load:

```yaml title="plugins/AuthMe/config.yml"
DataSource:
  backend: 'MYSQL'
  mySQLHost: 'localhost'
  mySQLPort: '3306'
  mySQLDatabase: 'minecraft_authme'
  mySQLUsername: 'authme_user'
  mySQLPassword: 'secure_password_here'
  mySQLTablename: 'authme'
  mySQLPoolSize: 10
```

```sql title="setup.sql"
CREATE DATABASE minecraft_authme;
CREATE USER 'authme_user'@'localhost' IDENTIFIED BY 'secure_password_here';
GRANT ALL PRIVILEGES ON minecraft_authme.* TO 'authme_user'@'localhost';
FLUSH PRIVILEGES;
```

## Testing Authentication

Here's how to make sure your auth setup actually works.

### Registration and Login

Join with a fresh account. You should be frozen in place, unable to move, chat, or run commands other than `/register` and `/login`. Run `/register <password> <password>` and confirm you can now move and interact. Disconnect, reconnect, and verify you're frozen again until you run `/login <password>`.

If sessions are enabled, reconnecting within the timeout window (default 10 minutes) should auto-login you without requiring `/login`. Reconnecting after the timeout should require manual login again.

### Password Validation

Try registering with passwords from your `unsafePasswords` list (e.g., `123456`). Each should be rejected. Try using your username as the password -- AuthMe should block that too. Passwords shorter than `minPasswordLength` should also get rejected.

Test the password change flow: register, run `/changepassword oldpass newpass`, disconnect, reconnect, and confirm only the new password works.

### Brute Force Protection

With `maxLoginTries: 3` and `tempBanLength: 5`, enter the wrong password three times. After the third attempt, you should be kicked with a message about too many failed attempts. Any further connection attempts during the ban window should get rejected too.

### Restriction Enforcement

Before logging in, check that all of these are blocked:

- Movement (if `allowMovement: false`)
- Chat messages (if `allowChat: false`)
- Commands other than those in `allowCommands`

Also confirm the kick timeout works: join, do nothing, and after the configured seconds you should be disconnected.

### Database Persistence

Register an account, stop the server, restart it, and login. The account should persist. Verify the entry exists in your database:

```sql title="verify.sql"
SELECT username, ip, regdate FROM authme WHERE username = 'TestPlayer';
```

### Case-Sensitivity and Impersonation

If a player registers as "Notch", can someone else join as "notch"? Without `preventOtherCase: true`, AuthMe treats them as separate accounts -- which means impersonation is wide open. Turn it on:

```yaml title="plugins/AuthMe/config.yml"
settings:
  preventOtherCase: true
```

With this set, "notch" will be rejected when "Notch" is already registered.

## Hybrid Authentication with FastLogin

[FastLogin](https://github.com/games647/FastLogin) sits in front of AuthMe and automatically detects premium accounts. Premium players skip the password flow entirely; cracked players fall through to AuthMe's `/register` and `/login`.

Test three scenarios:

1. **Premium account** -- should auto-login with no password prompt
2. **Cracked account** -- should be required to register and login via AuthMe
3. **Cracked client using a premium username** -- should be rejected to prevent impersonation

## Security Testing

### SQL Injection

On your own test server, try registering with payloads like `/register ' OR '1'='1 password`. AuthMe should reject or escape these. If any succeed, you're running a dangerously outdated version -- update immediately.

### Timing Attacks

Run `/login ExistingUser wrongpass` and `/login FakeUser wrongpass` and compare response times. Modern AuthMe uses constant-time comparison, so both should respond in roughly the same time. A measurable difference leaks whether an account exists.

### Session Security

With `ipCheck: true`, a session token from one IP shouldn't work from a different one. Log in, note the session, then try to resume it from a different address. The server should force you to re-authenticate.

## Load Testing with Bots

Manual testing covers correctness, but you need bots to test what happens under real load -- concurrency issues and performance problems won't show up any other way.

### What to Test

**Mass registration**: Connect 50 bots at once, each registering a unique account. They should all succeed -- no race conditions, no duplicate key errors in the database.

**Login throughput**: Disconnect all 50, then reconnect them at once. Each runs `/login`. Watch for timeouts, failed logins, or "too many connections" errors from your database.

**Session timeout accuracy**: Log in a bot, disconnect, reconnect within the session window, and confirm it auto-logs in. Reconnect after the window expires -- this time it should ask for a password.

### What to Monitor

```bash title="terminal"
# Auth events in real time
tail -f logs/latest.log | grep -i "authme\|login\|register"

# Database connection count (MySQL)
mysql -e "SHOW PROCESSLIST;"

# Server TPS under load
/spark tps
```

A healthy auth system handles 100 concurrent logins without dropping TPS below 19. If you see timeouts or "too many connections" errors, increase your database connection pool or switch from SQLite to MySQL.

## Best Practices

**Stick with online mode** if you can. It's the simplest and most secure setup by far.

If you do run offline mode, always pair it with AuthMe or something equivalent -- never leave it unprotected.

A few things that are easy to get wrong:

- Hash passwords with BCRYPT2Y. SHA256 isn't good enough for password storage.
- Bind sessions to IP (`ipCheck: true`) so stolen session tokens can't be reused from somewhere else.
- Cap registrations per IP. One or two is usually plenty; more than that and you're inviting spam accounts.
- Set `maxLoginTries` to 3-5 and enable temp bans. Brute forcing should be painful.

On the infrastructure side, use MySQL for anything beyond a dev server -- SQLite doesn't handle concurrent logins well. And test under load before you go live. Race conditions and connection pool exhaustion are the kind of bugs that only show up when 50 players log in at once.

Auth is your server's front door. Test it the way an attacker would -- with automation, edge cases, and bad input -- and you'll know it holds up before your players have to find out the hard way.
