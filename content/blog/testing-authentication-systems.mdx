---
title: Testing Minecraft Authentication Systems - Security and Login Flow
description: Learn how to test authentication plugins like AuthMe, validate Microsoft/Mojang auth, and ensure secure login flows on your Minecraft server
author: Pistonmaster
date: 2026-02-08
tags: [minecraft, authentication, authme, security, offline-mode, login]
---

import { Callout } from 'fumadocs-ui/components/callout'

## Understanding Minecraft Authentication

Authentication determines who can join your server and how their identity is verified. Minecraft supports two modes out of the box, and plugins extend offline mode with password-based security.

### Online vs Offline Mode

**Online mode** (`online-mode=true` in `server.properties`) is the default. The server contacts Mojang/Microsoft to verify the player owns the account before allowing them in. It requires no plugins, prevents impersonation via real UUIDs, and is the most secure option. The tradeoff is a hard dependency on Mojang's servers being reachable.

**Offline mode** (`online-mode=false`) skips verification entirely. Anyone can connect with any username, which is useful for local development or behind a proxy that handles auth upstream.

<Callout type="danger">
**Never run offline mode on a public server without an authentication plugin.** Without one, any player can join as any username, including admin accounts. This is the single most common way servers get compromised.
</Callout>

### Plugin-Based Authentication

For offline mode servers, authentication plugins add password-based login:

| Plugin | Approach | Best For |
|--------|----------|----------|
| [AuthMe](https://github.com/AuthMe/AuthMeReloaded) | Password registration/login | Public offline servers |
| [FastLogin](https://github.com/games647/FastLogin) | Hybrid online/offline detection | Mixed premium + cracked players |
| nLogin | Simple password auth | Small servers |

## AuthMe Configuration

[AuthMe](https://github.com/AuthMe/AuthMeReloaded) is the most widely used auth plugin. Drop the JAR into your `plugins/` folder and restart; it generates its config on first boot.

### Core Settings

```yaml title="plugins/AuthMe/config.yml"
settings:
  sessions:
    enabled: true
    timeout: 10        # Minutes before requiring re-login
    ipCheck: true      # Bind sessions to IP

registration:
  enabled: true
  force: true
  messageInterval: 5
  maxRegPerIp: 1       # Prevent spam accounts

security:
  minPasswordLength: 5
  maxPasswordLength: 30
  passwordHash: 'BCRYPT2Y'
  bCryptLog2Rounds: 10
  maxLoginTries: 3
  tempBanLength: 5     # Minutes after max failed attempts
  unsafePasswords:
    - '123456'
    - 'password'
    - 'qwerty'

timeout:
  kick: 30             # Seconds before kicking unauthenticated players

restrictions:
  allowCommands:
    - '/login'
    - '/register'
    - '/l'
    - '/reg'
  allowMovement: false
  allowChat: false
```

<Callout type="warning">
**Always use BCRYPT or BCRYPT2Y for password hashing.** SHA256 is vulnerable to rainbow table attacks and should never be used for password storage.
</Callout>

### Database Backend

SQLite works for development, but production servers should use MySQL for better concurrency under load:

```yaml title="plugins/AuthMe/config.yml"
DataSource:
  backend: 'MYSQL'
  mySQLHost: 'localhost'
  mySQLPort: '3306'
  mySQLDatabase: 'minecraft_authme'
  mySQLUsername: 'authme_user'
  mySQLPassword: 'secure_password_here'
  mySQLTablename: 'authme'
  mySQLPoolSize: 10
```

```sql title="setup.sql"
CREATE DATABASE minecraft_authme;
CREATE USER 'authme_user'@'localhost' IDENTIFIED BY 'secure_password_here';
GRANT ALL PRIVILEGES ON minecraft_authme.* TO 'authme_user'@'localhost';
FLUSH PRIVILEGES;
```

## Testing Authentication

Proper testing ensures your authentication actually protects players. Below are the key scenarios to validate, covering registration, login, security, and edge cases.

### Registration and Login

Join with a fresh account. You should be frozen in place, unable to move, chat, or run commands other than `/register` and `/login`. Run `/register <password> <password>` and confirm you can now move and interact. Disconnect, reconnect, and verify you are frozen again until you run `/login <password>`.

If sessions are enabled, reconnecting within the timeout window (default 10 minutes) should auto-login you without requiring `/login`. Reconnecting after the timeout should require manual login again.

### Password Validation

Attempt to register with passwords from your `unsafePasswords` list (e.g., `123456`). Each should be rejected. Try using your username as the password. AuthMe should block that too. Verify that passwords shorter than `minPasswordLength` are rejected.

Test the password change flow: register, run `/changepassword oldpass newpass`, disconnect, reconnect, and confirm only the new password works.

### Brute Force Protection

With `maxLoginTries: 3` and `tempBanLength: 5`, enter the wrong password three times. After the third attempt, you should be kicked with a message about too many failed attempts. Further connection attempts during the ban window should also be rejected.

### Restriction Enforcement

While unauthenticated, verify the following are all blocked:

- Movement (if `allowMovement: false`)
- Chat messages (if `allowChat: false`)
- Commands other than those in `allowCommands`

Also confirm the kick timeout works: join, do nothing, and after the configured seconds you should be disconnected.

### Database Persistence

Register an account, stop the server, restart it, and login. The account should persist. Verify the entry exists in your database:

```sql title="verify.sql"
SELECT username, ip, regdate FROM authme WHERE username = 'TestPlayer';
```

### Case-Sensitivity and Impersonation

If a player registers as "Notch", can someone else join as "notch"? Without `preventOtherCase: true`, AuthMe treats them as separate accounts, which enables impersonation. Enable it:

```yaml title="plugins/AuthMe/config.yml"
settings:
  preventOtherCase: true
```

With this set, "notch" will be rejected when "Notch" is already registered.

## Hybrid Authentication with FastLogin

[FastLogin](https://github.com/games647/FastLogin) sits in front of AuthMe and automatically detects premium accounts. Premium players skip the password flow entirely; cracked players fall through to AuthMe's `/register` and `/login`.

Test three scenarios:

1. **Premium account** -- should auto-login with no password prompt
2. **Cracked account** -- should be required to register and login via AuthMe
3. **Cracked client using a premium username** -- should be rejected to prevent impersonation

## Security Testing

### SQL Injection

On your own test server, try registering with payloads like `/register ' OR '1'='1 password`. AuthMe should reject or escape these. If any succeed, you are running a dangerously outdated version and must update immediately.

### Timing Attacks

Run `/login ExistingUser wrongpass` and `/login FakeUser wrongpass` and compare response times. Modern AuthMe uses constant-time comparison, so both should respond in roughly the same time. A measurable difference leaks whether an account exists.

### Session Security

With `ipCheck: true`, a session token obtained from one IP should not work from a different IP. Verify by logging in, noting the session, and attempting to resume it from a different address. The server should require re-authentication.

## Load Testing with Bots

Manual testing covers correctness, but bots let you test concurrency and performance -- things that only surface under load.

### What to Test

**Mass registration**: Connect 50 bots simultaneously, each registering a unique account. All registrations should succeed with no race conditions or duplicate key errors in the database.

**Login throughput**: Disconnect all 50 bots, then reconnect them at once. Each runs `/login`. Monitor for timeouts, failed logins, or connection pool exhaustion in your database.

**Session timeout accuracy**: Log in a bot, disconnect, reconnect within the session window, and confirm auto-login. Reconnect after the window expires and confirm manual login is required.

### What to Monitor

```bash title="terminal"
# Auth events in real time
tail -f logs/latest.log | grep -i "authme\|login\|register"

# Database connection count (MySQL)
mysql -e "SHOW PROCESSLIST;"

# Server TPS under load
/spark tps
```

A healthy auth system handles 100 concurrent logins without dropping TPS below 19. If you see timeouts or "too many connections" errors, increase your database connection pool or switch from SQLite to MySQL.

## Best Practices

1. **Use online mode** whenever possible -- it is the most secure option
2. **If offline mode is necessary**, always pair it with AuthMe or equivalent
3. **Hash passwords with BCRYPT2Y** -- never SHA256
4. **Enable session IP checks** to prevent session hijacking
5. **Limit registrations per IP** to block spam accounts
6. **Set brute force protection** to 3-5 attempts before a temporary ban
7. **Use MySQL in production** for better concurrency than SQLite
8. **Test under load** to catch race conditions and pool exhaustion before players do

Authentication is your server's front door. Test it the way an attacker would -- with automation, edge cases, and bad input -- and you will know it holds up before your players have to find out the hard way.
