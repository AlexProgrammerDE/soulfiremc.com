---
title: Minecraft Server Automation - AFK Prevention and Bot Utilities
description: Learn how to automate server tasks, implement AFK prevention, auto-reconnect systems, and use bots for automated server maintenance
author: Pistonmaster
date: 2026-02-09
tags: [minecraft, automation, afk-prevention, server-management, bots]
---

import { Callout } from 'fumadocs-ui/components/callout'

## Server Automation Done Right

Running a Minecraft server means dealing with repetitive maintenance: backups, restarts, AFK kicks, and uptime monitoring. Instead of handling these manually, you can script them, or use bots to handle the in-game side. This guide covers the practical approaches to both.

<Callout type="warn">
**Respect server rules.** Bot-based approaches may violate a server's Terms of Service. Always get explicit permission from server administrators before deploying bots or client-side AFK tools. Unauthorized usage can result in permanent bans.
</Callout>

### AFK Prevention

AFK detection exists to free up player slots on busy servers. There are two sides to it: the server enforcing it, and players (or bots) working around it.

#### Server-Side: AFK Plugins

Most Spigot/Paper servers use plugins like [AntiAFK](https://www.spigotmc.org/resources/antiafk.63713/) or [AFK+](https://www.spigotmc.org/resources/afk.35065/) to detect idle players. A typical configuration looks like this:

```yaml title="config.yml"
detection:
  timeout: 300  # 5 minutes before marked AFK
  movement: true
  looking: true
  interact: true
  chat: true

actions:
  - type: MESSAGE
    message: "&eYou are now AFK"
  - type: KICK
    delay: 600  # 10 more minutes before kick
    message: "&cKicked for being AFK too long"
```

Grant bypass permissions (`afk.bypass`) to trusted ranks, and tune the timeout based on your player base. Too aggressive and you frustrate legitimate players; too lenient and you waste slots.

#### Client-Side: Anti-AFK Mods

Fabric/Forge mods like Anti-Anti-AFK add randomized behavior to avoid detection. The key is variance -- fixed intervals and single repeated actions are trivially detectable:

```java title="Anti-AFK Movement Pattern"
void avoidAFK() {
    // Random interval: 30-90 seconds
    int interval = 30000 + random.nextInt(60000);

    // Varied actions to avoid pattern detection
    int action = random.nextInt(4);
    switch(action) {
        case 0: jump();
        case 1: lookAround(random.nextFloat() * 360);
        case 2: sneakBriefly();
        case 3: swingArm();
    }
}
```

#### Bot-Based AFK Prevention

Bots can keep accounts logged in for legitimate purposes: loading chunks for farms, keeping free-tier hosts (Aternos, Minehut) online, or testing server stability. [SoulFire](https://soulfiremc.com) handles this natively with its Anti-AFK and Auto-Reconnect plugins, removing the need for custom scripts.

### Auto-Reconnect

Connection drops are inevitable -- network blips, server restarts, crashes. A good reconnect strategy uses exponential backoff and distinguishes between recoverable and permanent failures:

```python title="reconnect.py"
def reconnect_with_backoff():
    attempt = 0
    max_attempts = 10

    while attempt < max_attempts:
        try:
            connect_to_server()
            return  # Success
        except ServerOfflineError:
            time.sleep(60)  # Server down, wait longer
        except AuthenticationError:
            print("Auth failed, stopping")
            break  # Don't retry auth failures
        except ConnectionError:
            attempt += 1
            delay = min(2 ** attempt, 300)  # Cap at 5 minutes
            print(f"Attempt {attempt} failed. Retry in {delay}s")
            time.sleep(delay)
```

For client-side mods, [ReconnectMod](https://modrinth.com/mod/reconnect) and [Auto Reconnect](https://www.curseforge.com/minecraft/mc-mods/auto-reconnect) handle this with configurable delays, attempt limits, and reason-based filtering (don't reconnect after a ban).

### Monitoring and Alerting

A crashed server that nobody notices for hours is worse than one that pages you immediately.

#### Health Check Script

This script checks if the server process is running and whether TPS has dropped, then sends Discord alerts:

```bash title="monitor-server.sh"
#!/bin/bash

# Check if server process is running
if ! pgrep -f "paper.jar" > /dev/null; then
    curl -X POST "$DISCORD_WEBHOOK" \
      -H "Content-Type: application/json" \
      -d '{"content": "Server is DOWN! Attempting restart..."}'
    cd /path/to/server && ./start.sh
    exit 1
fi

# Check TPS via RCON (requires rcon-cli)
TPS=$(rcon-cli "spark tps" | grep -oP "TPS: \K[0-9.]+")
if (( $(echo "$TPS < 18" | bc -l) )); then
    curl -X POST "$DISCORD_WEBHOOK" \
      -H "Content-Type: application/json" \
      -d "{\"content\": \"Low TPS warning: $TPS\"}"
fi
```

Schedule it with [cron](https://man7.org/linux/man-pages/man5/crontab.5.html):

```bash title="crontab"
*/5 * * * * /path/to/monitor-server.sh
```

#### Player Count Tracking

The [mcstatus](https://pypi.org/project/mcstatus/) library lets you poll player counts externally and alert on anomalies:

```python title="player-monitor.py"
from mcstatus import JavaServer

def check_players():
    server = JavaServer.lookup("play.yourserver.com")
    status = server.status()

    if status.players.online >= status.players.max:
        send_discord_alert("Server is full!")
    if status.players.online == 0:
        check_empty_duration()  # Alert if empty for 6+ hours

    log_player_count(status.players.online)
```

### Automated Backups

Data loss from a corrupted world with no recent backup is the nightmare scenario. This script handles the full cycle: warn players, disable saving, archive, re-enable, and clean up old backups:

```bash title="backup-server.sh"
#!/bin/bash

DATE=$(date +%Y-%m-%d_%H-%M-%S)
SERVER_DIR="/path/to/server"
BACKUP_DIR="/path/to/backups"

mkdir -p "$BACKUP_DIR"
rcon-cli "say Backup starting in 30 seconds..."
sleep 30

rcon-cli "save-off"
rcon-cli "save-all flush"
sleep 10

tar -czf "$BACKUP_DIR/backup_$DATE.tar.gz" \
  -C "$SERVER_DIR" world world_nether world_the_end

rcon-cli "save-on"
rcon-cli "say Backup complete!"

# Retain 7 days of backups
find "$BACKUP_DIR" -name "backup_*.tar.gz" -mtime +7 -delete
```

```bash title="crontab"
# Daily at 4 AM, plus hourly during peak hours
0 4 * * * /path/to/backup-server.sh
0 14-22 * * * /path/to/backup-server.sh
```

### Graceful Restarts

Regular restarts clear memory leaks and apply updates. The key is giving players enough warning without turning the countdown into a wall of chat spam:

```bash title="restart-server.sh"
#!/bin/bash

rcon-cli "say Server restarting in 5 minutes!"
sleep 240
rcon-cli "say Server restarting in 1 minute!"
sleep 50
for i in 10 5 4 3 2 1; do
    rcon-cli "say Restarting in $i..."
    sleep 1
done

rcon-cli "stop"
sleep 30
cd /path/to/server && ./start.sh
```

For automatic Paper updates before restart, the [Paper downloads API](https://docs.papermc.io/misc/downloads-api) lets you check for new builds and swap the jar programmatically:

```bash title="update-check.sh"
#!/bin/bash

SERVER_DIR="/path/to/server"
PAPER_API="https://api.papermc.io/v2/projects/paper"
VERSION="1.21"

LATEST_BUILD=$(curl -s "$PAPER_API/versions/$VERSION/builds" | jq -r '.builds[-1].build')
CURRENT_BUILD=$(cat "$SERVER_DIR/paper-version.txt" 2>/dev/null || echo "0")

if [ "$LATEST_BUILD" != "$CURRENT_BUILD" ]; then
    wget -q "$PAPER_API/versions/$VERSION/builds/$LATEST_BUILD/downloads/paper-$VERSION-$LATEST_BUILD.jar" \
      -O "$SERVER_DIR/paper-new.jar"
    mv "$SERVER_DIR/paper.jar" "$SERVER_DIR/paper-old.jar"
    mv "$SERVER_DIR/paper-new.jar" "$SERVER_DIR/paper.jar"
    echo "$LATEST_BUILD" > "$SERVER_DIR/paper-version.txt"
fi
```

### Bot Use Cases with SoulFire

While shell scripts handle external server management, bots handle the in-game side. [SoulFire](https://soulfiremc.com) is purpose-built for these scenarios:

- **Chunk loading**: Bots sit near farms to keep chunks loaded 24/7. Minimal movement, just enough anti-AFK to stay connected.
- **Free-host uptime**: Keep Aternos/Minehut servers from shutting down when no real players are online. Check the host's ToS first -- some explicitly prohibit this.
- **Stress testing**: Spin up 50 bots performing varied actions (movement, block interaction, chat) to measure TPS impact, memory usage, and error rates over extended periods.
- **Pre-launch chunk generation**: Bots explore the world in expanding patterns before launch day, catching terrain generation issues early and improving performance when real players arrive.
- **Server testing**: Validate that AFK detection, auto-reconnect flows, and session persistence all work correctly under realistic conditions.

SoulFire's plugin system (Anti-AFK, Auto-Reconnect, Auto-Respawn) handles the common bot behaviors out of the box, so you spend time configuring rather than coding.

### Best Practices

<Callout type="info">
**Key principles for reliable server management:**

1. **Start simple** -- get basic monitoring and backups working before adding bot-driven workflows
2. **Handle failures** -- every script needs error handling; every bot needs reconnect logic
3. **Monitor the monitors** -- automated systems themselves can fail silently
4. **Stagger bot logins** -- connecting 50 bots simultaneously will spike server load
5. **Secure credentials** -- use environment variables, never hardcode passwords or webhook URLs
6. **Log everything** -- structured logging makes debugging failed 3 AM backups possible
7. **Have kill switches** -- the ability to stop all bots or scripts instantly when something goes wrong
</Callout>

### Conclusion

Server management boils down to two categories: external tasks (backups, restarts, monitoring) handled by shell scripts and cron, and in-game tasks (AFK prevention, chunk loading, stress testing) handled by bots. Get the external fundamentals in place first, then layer in bot-driven workflows where they add real value. The best setup is one where you only hear from your server when something actually needs attention.
