---
title: Testing Minecraft Plugins and Minigames - A Developer's Guide
description: Learn how to test Minecraft plugins with MockBukkit, WatchWolf, and automated testing frameworks, plus strategies for testing multiplayer minigames
author: Pistonmaster
date: 2026-02-06
tags: [minecraft, plugin-development, testing, mockbukkit, minigames, java]
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Callout } from 'fumadocs-ui/components/callout'

## Why Testing Matters for Plugin Development

Every plugin developer has shipped something that worked in dev and broke in production. AFK players triggering edge cases, Paper updates shifting behavior, two plugins conflicting in ways nobody predicted. Testing is how you stop firefighting and start shipping with confidence.

This guide covers the full testing stack: MockBukkit for fast unit tests, WatchWolf for real server integration, and bot-driven testing for minigames that need actual concurrent players.

## Unit Testing with MockBukkit

[MockBukkit](https://github.com/MockBukkit/MockBukkit) is the standard testing framework for Bukkit/Paper plugins. It simulates a server in-process, so tests run in milliseconds without spinning up Minecraft.

### Setup

<Tabs items={['Maven', 'Gradle']}>
  <Tab value="Maven">
    ```xml title="pom.xml"
    <dependencies>
        <dependency>
            <groupId>io.papermc.paper</groupId>
            <artifactId>paper-api</artifactId>
            <version>1.21-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>com.github.seeseemelk</groupId>
            <artifactId>MockBukkit-v1.21</artifactId>
            <version>4.0.0</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    ```
  </Tab>

  <Tab value="Gradle">
    ```groovy title="build.gradle"
    dependencies {
        compileOnly 'io.papermc.paper:paper-api:1.21-R0.1-SNAPSHOT'

        testImplementation 'com.github.seeseemelk:MockBukkit-v1.21:4.0.0'
        testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    }
    ```
  </Tab>
</Tabs>

### Basic Test Structure

Every MockBukkit test follows the same pattern: mock the server, load your plugin, run tests, then tear down.

```java title="MyPluginTest.java"
import be.seeseemelk.mockbukkit.MockBukkit;
import be.seeseemelk.mockbukkit.ServerMock;
import be.seeseemelk.mockbukkit.entity.PlayerMock;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

public class MyPluginTest {

    private ServerMock server;
    private MyPlugin plugin;

    @BeforeEach
    public void setUp() {
        server = MockBukkit.mock();
        plugin = MockBukkit.load(MyPlugin.class);
    }

    @AfterEach
    public void tearDown() {
        MockBukkit.unmock();
    }

    @Test
    public void testPluginLoads() {
        assertNotNull(plugin);
        assertTrue(plugin.isEnabled());
    }
}
```

### Testing Commands and Events

Commands and events are the core of most plugins. MockBukkit lets you dispatch commands, fire events, and assert the results.

```java title="FlyCommandTest.java"
@Test
public void testFlyCommand() {
    PlayerMock player = server.addPlayer("TestPlayer");

    boolean success = server.dispatchCommand(player, "fly");

    assertTrue(success, "Command should execute successfully");
    assertTrue(player.getAllowFlight(), "Player should have flight enabled");
    player.assertSaid("Flight enabled!");
}

@Test
public void testFlyCommandRequiresPermission() {
    PlayerMock player = server.addPlayer("TestPlayer");

    server.dispatchCommand(player, "fly");

    assertFalse(player.getAllowFlight());
    player.assertSaid("You don't have permission!");
}
```

Events work the same way -- create the event, fire it through the plugin manager, and check the outcome:

```java title="EventHandlerTest.java"
@Test
public void testDamageReduction() {
    PlayerMock player = server.addPlayer("TestPlayer");
    player.getInventory().setHelmet(new ItemStack(Material.DIAMOND_HELMET));

    EntityDamageEvent event = new EntityDamageEvent(
        player,
        EntityDamageEvent.DamageCause.ENTITY_ATTACK,
        10.0
    );

    server.getPluginManager().callEvent(event);

    assertTrue(event.getDamage() < 10.0, "Damage should be reduced by armor");
}
```

### Testing Inventories

GUI plugins need inventory tests. MockBukkit tracks open inventories and supports click simulation:

```java title="ShopGUITest.java"
@Test
public void testShopGUI() {
    PlayerMock player = server.addPlayer("TestPlayer");
    plugin.openShopGUI(player);

    Inventory inv = player.getOpenInventory().getTopInventory();

    assertEquals(27, inv.getSize(), "Shop should be 3 rows");
    assertNotNull(inv.getItem(0));
    assertEquals(Material.DIAMOND_SWORD, inv.getItem(0).getType());
}
```

<Callout type="warn">
Async tests are tricky with MockBukkit. Avoid `Thread.sleep()` -- use `CountDownLatch` or `CompletableFuture` for reliable timing in async test assertions.
</Callout>

## Integration Testing with WatchWolf

MockBukkit simulates the API, but it can't test networking, real tick timing, or packet-level behavior. [WatchWolf](https://github.com/AlchemistITRoad/WatchWolf) fills that gap by launching actual Minecraft servers and connecting real clients.

```java title="MinigameIntegrationTest.java"
public class MinigameIntegrationTest {

    @Test
    public void testMinigameFlow() throws Exception {
        try (WatchWolf watchWolf = new WatchWolf()) {
            ServerDescriptor server = watchWolf.startServer("1.21", "paper");
            server.installPlugin("MyPlugin.jar");
            server.waitForStartup();

            ClientDescriptor player1 = watchWolf.startClient("Player1");
            ClientDescriptor player2 = watchWolf.startClient("Player2");

            player1.connect(server);
            player2.connect(server);

            player1.executeCommand("/minigame join");
            player2.executeCommand("/minigame join");

            Thread.sleep(5000);

            assertTrue(server.isPlayerOnline("Player1"));
            assertTrue(server.isPlayerOnline("Player2"));
        }
    }
}
```

WatchWolf tests are slow (30+ seconds each) and resource-heavy, so use them selectively for scenarios that genuinely need real server behavior. MockBukkit should still be your primary testing tool.

## Continuous Integration

Run tests automatically on every commit with [GitHub Actions](https://docs.github.com/en/actions):

```yaml title=".github/workflows/test.yml"
name: Plugin Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}

      - name: Run tests
        run: mvn test

      - name: Generate test report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Test Results
          path: target/surefire-reports/*.xml
          reporter: java-junit
```

Set this up once and every push catches regressions before they reach your players.

## Testing Minigames with Bots

Minigames have problems that MockBukkit and WatchWolf alone cannot catch: concurrent player actions causing race conditions, network disconnects mid-game, lobby countdown edge cases, arena cleanup failures after dozens of rounds. These require sustained testing with multiple real clients.

### What Bots Test That Mocks Cannot

MockBukkit gives you simulated players. Bots give you real protocol connections hitting your server concurrently. The difference matters for:

- **Thread safety**: Ten bots opening chests at the same tick exposes race conditions that sequential mock calls never will.
- **Network edge cases**: A bot disconnecting mid-teleport tests your cleanup code in ways `server.removePlayer()` does not.
- **Tick-accurate timing**: Lobby countdowns, grace periods, and respawn delays depend on real server ticks, not simulated ones.

### Key Scenarios to Test

**Lobby threshold and countdown**: Connect bots one at a time up to your minimum player count. Verify the game stays in WAITING until the threshold is met, starts the countdown on the right join, and transitions to ACTIVE after the countdown finishes. Then test what happens when a player leaves during the countdown -- does it cancel or continue?

**Mid-game disconnects**: Start a game with the minimum players, then disconnect one bot. The game should handle the removal cleanly: remove them from the active player list, check if a win condition is now met, and not throw exceptions on the next tick when it tries to reference the missing player.

**Simultaneous actions**: Have all bots perform an action on the same tick -- breaking a block, clicking an NPC, or entering a region trigger. This is where concurrency bugs hide. If your plugin stores game state in a `HashMap` instead of a `ConcurrentHashMap`, this is where it shows.

**Full lifecycle endurance**: Run the complete cycle -- lobby, countdown, gameplay, win condition, cleanup, arena reset, next round -- for 20-30 minutes. Watch for memory leaks (arena snapshots not being freed), TPS degradation, and state that leaks between rounds.

### Using SoulFire for Minigame Testing

[SoulFire](https://soulfiremc.com) is particularly effective for this because its Fabric-based client architecture means bots behave like real players at the protocol level. Physics, movement, and packet handling all match a genuine Minecraft client.

A typical test setup: configure 8 bots with staggered join delays (2-4 seconds between each), enable the Auto Respawn and Anti-AFK plugins so bots behave naturally, and let them run through your minigame. Monitor server TPS with [Spark](https://spark.lucko.me/) and watch your server logs for exceptions.

The things to look for are straightforward: Did all bots join the game? Did the game start when expected? Did TPS stay above 19? Did the game end and clean up properly? Any `NullPointerException` or `ConcurrentModificationException` in the logs means you have a bug that would have hit real players.

<Callout type="warn">
Bot testing complements MockBukkit -- it does not replace it. Use MockBukkit for fast iteration on game logic, and bot testing for validating that logic holds up under real conditions.
</Callout>

## Choosing the Right Tool

Each testing layer catches different classes of bugs:

- **[MockBukkit](https://github.com/MockBukkit/MockBukkit)**: Fast, in-process tests for commands, events, inventories, and game logic. Run these on every commit.
- **[WatchWolf](https://github.com/AlchemistITRoad/WatchWolf)**: Real server/client tests for protocol-level and timing-sensitive behavior. Run these for critical paths.
- **[SoulFire](https://soulfiremc.com)**: Multi-bot stress testing and realistic minigame simulation. Run these before releases and after major changes.

Start with MockBukkit coverage for your core logic, add WatchWolf tests for scenarios that need real servers, and use SoulFire to validate that your minigame survives contact with actual concurrent players. The time you invest in testing is time you do not spend debugging production crashes.
